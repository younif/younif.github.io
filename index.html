<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"younif.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":-1,"unescape":true,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Youni Blog">
<meta property="og:url" content="https://younif.github.io/index.html">
<meta property="og:site_name" content="Youni Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Youni">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://younif.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Youni Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Youni Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">9</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/hello-world/" class="post-title-link" itemprop="url">Youni Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-18 21:24:00 / 修改时间：21:52:56" itemprop="dateCreated datePublished" datetime="2022-09-18T21:24:00+08:00">2022-09-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>用于记录学习并输出知识。</p>
<p>测试</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EIO/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-18 21:24:00 / 修改时间：22:44:19" itemprop="dateCreated datePublished" datetime="2022-09-18T21:24:00+08:00">2022-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字符与字节"><a href="#字符与字节" class="headerlink" title="字符与字节"></a>字符与字节</h1><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>字符串类库由<code>base_string&lt;&gt;</code>模板与几个标准特化版<code>string wstring u16string u32string</code>组成。</li>
<li>string中不以<code>\0</code>判定结尾，所以可以使用string包含任何字符。</li>
<li>转换成c-string：<code>data()</code>、<code>c_str()</code>，结尾包含<code>\0</code></li>
<li>转换成字符数组：<code>copy(char* des, int maxlen, int posStr)</code>，结尾不包含<code>\0</code></li>
</ul>
<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string::size_type <span class="comment">//搜索时返回的是该无符号类型，不应该使用有符号int，比较时会出现问题。</span></span><br><span class="line"><span class="keyword">auto</span> idx = filename.<span class="built_in">find</span>(<span class="string">&#x27;&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">string::npos</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">substr(pos,len)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">replace(pos, len, str)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">find()/find_frist_of() </span></span><br></pre></td></tr></table></figure>

<h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ul>
<li><code>[]</code> 不检查有效，无效未定义行为</li>
<li><code>at()</code> 无效时抛出异常</li>
<li>最末字符后存在，且为<code>\0</code>，但<code>at(length)</code> 非法</li>
<li><code>front()</code> 返回<code>[0]</code>，空string时其值为<code>\0</code></li>
<li>空string时，<code>back()</code>未定义</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><ul>
<li><p><code>assign()</code>赋值可以如初始化一样使用多个实参</p>
</li>
<li><p><code>swap(string s)</code>，常量复杂度的成员函数</p>
</li>
<li><p><code>clean()/erase()</code> 清空</p>
</li>
<li><p><code>insert(int pos，string s)</code></p>
</li>
<li><p><code>remove()</code></p>
</li>
<li><p><code>replace()</code></p>
</li>
<li><p><code>erase()</code></p>
</li>
<li><p><code>push_back()</code> 为后插迭代器设置</p>
</li>
<li><p><code>append()</code> 可使用多个实参</p>
</li>
<li><p><code>operator+=()</code></p>
</li>
<li><p><code>resize()</code> 改变字符数量</p>
</li>
</ul>
<h2 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h2><ul>
<li><code>substr()</code></li>
<li><code>operator+()</code>，当字符串不再使用时，使用move语义。</li>
</ul>
<h2 id="搜索与查找"><a href="#搜索与查找" class="headerlink" title="搜索与查找"></a>搜索与查找</h2><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>读取一串字符：</p>
<p>读取一行字符：</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>固定小数位：</p>
<h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-09-18 21:21:48 / 修改时间：21:33:51" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>数据和操作封装，只暴露接口，从而获得数据抽象。</p>
<ul>
<li>public定义可在外部访问</li>
<li>protected 可在类的内部和其派生类中访问</li>
<li>private只能在类内访问</li>
<li>继承定义了最小保护区间，与在父类的情况取最严格的属性。严格顺序：<code>public &gt; protected &gt; private</code> 。所以public继承访问控制不变。protected 继承可在类的内部和其派生类中访问。private继承仅可在本类中使用。</li>
</ul>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>通过继承的方式复用代码。由封装可分为：实现继承、接口继承。</p>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>通过复写接口代码，使得相同接口可以表现不同。</p>
<ul>
<li><p>重载多态：函数重载</p>
<ul>
<li>name mangling规则：对函数参数与函数名进行编码，生成新的函数名。<ul>
<li>不编码返回值，因为。</li>
<li>顶层const修饰无法区分因为，顶层指针是拷贝。</li>
<li>不同的作用下，同名函数会覆盖。</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="虚函数多态"><a href="#虚函数多态" class="headerlink" title="虚函数多态"></a>虚函数多态</h2></li>
<li><p>模板参数多态</p>
</li>
<li><p>类型多态：强制类型转换</p>
</li>
</ul>
<h1 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h1><h2 id="构造、析构的调用顺序"><a href="#构造、析构的调用顺序" class="headerlink" title="构造、析构的调用顺序"></a>构造、析构的调用顺序</h2><p>由继承深度与派生表顺序依次调用基类构造函数，然后按照类中被声明的顺序依次调用类成员构造函数。<br>析构函数则与之相反。</p>
<h1 id="拷贝构造、赋值"><a href="#拷贝构造、赋值" class="headerlink" title="拷贝构造、赋值"></a>拷贝构造、赋值</h1><p>拷贝构造函数是根据原有对象生成一个“新”对象。赋值运算符将一个对象的值复制到“旧”对象的空间中，复制过程中需要判断目标与源对象是否为同一个对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Student s1 = <span class="number">2</span>;    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">Student s2;</span><br><span class="line">s2 = s;    <span class="comment">// 赋值运算符操作</span></span><br></pre></td></tr></table></figure>

<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>值语义与引用语义。值语义在复制后与源对象的内容无关，而引用语义共享同一内部对象。深拷贝指在引用语义下，做值语义复制。浅拷贝则指在引用语义下，只拷贝引用，而共享同一份引用指向的元素。</p>
<h2 id="虚函数与构造、析构"><a href="#虚函数与构造、析构" class="headerlink" title="虚函数与构造、析构"></a>虚函数与构造、析构</h2><p>构造函数不能为虚函数。这是个鸡与蛋的问题，因为构造函数需要设置虚函数表指针，而虚函数通过虚函数表指针获得其确定函数。</p>
<p>如果构造函数中调用虚函数则在编译期绑定为本类函数。因为构造函数必须明确自身所正在构造的对象是什么。</p>
<p>析构函数可以为虚函数，并且在运用运行时多态时需要虚析构函数来调用正确的析构函数。</p>
<h2 id="面试经典问题"><a href="#面试经典问题" class="headerlink" title="面试经典问题"></a>面试经典问题</h2><ul>
<li><p>如果在构造函数中调用memset(this, 0, sizeof(*this))来初始化内存空间，有什么问题吗？</p>
<p>对于有虚函数和虚表存在的类，这会将编译器插入的虚函数表指针等内容清空。</p>
</li>
</ul>
<h1 id="覆盖、重载和隐藏"><a href="#覆盖、重载和隐藏" class="headerlink" title="覆盖、重载和隐藏"></a>覆盖、重载和隐藏</h1><ul>
<li><p>重载：同一作用域、相同函数名、参数列表不同的函数（不关心返回值），方法：函数名重命名。</p>
</li>
<li><p>隐藏（重定义）：作用域嵌套、相同函数名，内部作用域函数将外部所有重载函数全覆盖。</p>
</li>
<li><p>覆盖（覆写、重写）：派生类中重新定义与父类只有函数体有区别的函数。此时重写虚函数则根据虚函数表指针来调用对应的表中函数，而非虚函数则编译期按类型调用对应函数。</p>
</li>
</ul>
<h1 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h1><p>虚函数将所需要调用的函数与实例化的类所绑定，不与其指针类型所绑定，所以需要在运行时读取器内存，并查找虚函数表来确定需要调用的函数。<br>纯虚函数是未实现的虚函数，当然也可以定义，但是不能实例化，纯虚函数相作为接口名声明。</p>
<h2 id="虚函数与内联"><a href="#虚函数与内联" class="headerlink" title="虚函数与内联"></a>虚函数与内联</h2><p>所调用的虚函数在编译期可确定时可内联，即使用类名指定其函数，此时虚函数不具有多态性。</p>
<h2 id="虚函数与虚继承"><a href="#虚函数与虚继承" class="headerlink" title="虚函数与虚继承"></a>虚函数与虚继承</h2><ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：<ul>
<li>虚继承<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 21:21:48" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-13 10:22:36" itemprop="dateModified" datetime="2022-09-13T10:22:36+08:00">2022-09-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><p>宏定义变量一般全部大写，本质是对变量的文本匹配替换，用途：</p>
<ol>
<li>定义宏函数，可在预处理阶段可切换</li>
<li>加#define DEBUG用于控制程序调试。</li>
<li>使用编译器与头文件中的内部的宏变量来处理编译内容<ol start="4">
<li>硬件类型</li>
<li>运行库版本</li>
<li>编译器版本</li>
</ol>
</li>
<li>通过宏变量进行有选择的条件编译</li>
</ol>
<h2 id="编译器调试宏"><a href="#编译器调试宏" class="headerlink" title="编译器调试宏"></a>编译器调试宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__FUNCTION__ <span class="comment">//函数名</span></span><br><span class="line">__DATE__     <span class="comment">//日期</span></span><br><span class="line">__TIME__     <span class="comment">//时间</span></span><br><span class="line">__LINE__     <span class="comment">//行数</span></span><br><span class="line">__FILE__     <span class="comment">//文件</span></span><br></pre></td></tr></table></figure>

<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>头文件包含只能被定义一次的实体、声明的接口信息，如类、const、constexpr、函数声明、变量声明、模板定义、宏变量定义。头文件不应包含using声明，这会有入侵性，在不经意间引入名字而导致名字冲突。为了头文件不重复包含，使用头文件保护符<code>#ifndef NAME #define NAME -------#endif</code> 。</p>
<ul>
<li><p>变量声明和定义区别？</p>
<ul>
<li><p>声明仅把类型提供给编译器，并不为其分配内存空间；定义会为其分配存储空间。</p>
</li>
<li><p>相同变量可以再多处声明（外部变量extern），但只能在一处定义。</p>
</li>
</ul>
</li>
<li><p>模板与头文件</p>
<ul>
<li>当实例化模板时，编译器必须先解析模板，因此需要将模板的声明和定义都放置在同一个.h文件中。而普通的库文件则需要将声明和定义分开，并链接上即可。</li>
</ul>
</li>
</ul>
<h1 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> /<span class="keyword">ifndef</span> [id]</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> [id]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。</p>
</li>
<li><p>应对硬件的设置（机器类型等）。</p>
</li>
<li><p>条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。</p>
</li>
</ul>
<h1 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h1><ol>
<li><p>多条语句作为独立域可使用<code>do &#123;&#125; while(0)</code>，譬如if后的独立域。</p>
</li>
<li><p>运算对象，在整体之外加上括号<code>()</code></p>
</li>
<li><p>语句过长的情况，可以使用反斜杠<code>\</code></p>
</li>
</ol>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a><code>assert()</code></h2><p>定义在<code>&lt;cassert&gt;</code>中，是宏函数。用于确定某些条件，当不成立时快速失败。<code>assert(expr)</code> 对expr求值，如果表达式为假则输出信息并终止程序执行。在程序中不要定义名为assert的任何实体。<br>NDEBUG 预处理变量，如果#define了该变量，则assert什么也不做。也可以在编译时选择该命令行选项。我们也可以根据NDEBUG与<code>#ifdef #endif编写自己的条件调试代码，但是需要在源代码的开头， include &lt;assert.h&gt;</code> 之前。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span>( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>

<h1 id="C-替换预编译"><a href="#C-替换预编译" class="headerlink" title="C++替换预编译"></a>C++替换预编译</h1><p>Inline函数（有编译器的监视）、typedef类型重定义、const常量、条件编译使用template技术来解决</p>
<h3 id="宏函数与函数"><a href="#宏函数与函数" class="headerlink" title="宏函数与函数"></a>宏函数与函数</h3><ul>
<li>宏函数比函数执行更快，因为函数需要跳转到具体调用函地址。<ul>
<li>宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。</li>
<li>宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。</li>
<li>宏函数不要在最后加分号。</li>
</ul>
</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中，会检查数据类型。</li>
</ul>
<h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><ul>
<li>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。<ul>
<li>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</li>
<li>宏不检查类型；typedef会检查数据类型。</li>
<li>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</li>
<li>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</li>
</ul>
</li>
</ul>
<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><ul>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。<ul>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
<li>内联函数本身是函数，强调函数特性，具有重载等功能。</li>
<li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</li>
<li>内联函数是简单函数、不能递归定义、仅仅是对编译器的建议、应该放在头文件中，这样使用该函数的源文件都会内联、定义在类中的成员函数缺省都是内联的、放在函数声明前面不起inline作用、以代码膨胀为代价</li>
</ul>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">functionName</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">A::doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>

<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>展开宏定义、处理条件编译、处理#include指令、过滤掉注释、添加行号和文件名标识、保留#pragma指令</p>
<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p>词法分析 - 语法分析 - 语义分析 - 中间语言生成 - 目标代码生成与优化。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>将被编译的二进制文件组装起来成为整体就是链接，这将各个代码段相互的符号地址的引用加以修正。</p>
<ul>
<li><p>静态链接</p>
<p>将库文件链接到最终生成的可执行目标文件中，速度快但浪费内存。静态库生成是对多个目标文件（.o）打包，其包名格式为<code>lib*.a</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成静态库</span></span><br><span class="line">gcc -c test1.c    <span class="comment">// 生成test1.o</span></span><br><span class="line">gcc -c test2.c    <span class="comment">// 生成test2.o</span></span><br><span class="line">ar cr libtest.a test1.o test2.o</span><br><span class="line"><span class="comment">//使用静态库</span></span><br><span class="line">gcc -o main main.c -ltest</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态链接</p>
<p>可独立更新。当一个程序引用的两个动态库中存在同名函数时，先被加载的动态库函数有效，后家在的动态库同名函数无效（不会被执行）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">gcc -fPIC -c test1.c </span><br><span class="line">gcc -fPIC -c test2.c</span><br><span class="line">gcc -shared test1.o test2.o -o libtest.so</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">gcc -o main main.c -ltest</span><br><span class="line"><span class="comment">//默认在环境变量LD_LIBRARY_PATH指定的目录下搜索库文件</span></span><br><span class="line">-Lpath指定搜索库文件的目录</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>自动化编译工具，需要用户描述文件之间的依赖关系与相应的更新命令。make工具会检测文件的更新，并自动编译相关的依赖项。如下所述，其中A是目标文件，B是生成A所依赖的所有文件，下方描述了如何使用B去更新A的命令。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">A:B</span></span><br><span class="line">(tab)&lt;command&gt;</span><br><span class="line"></span><br><span class="line">test.o : test.c</span><br><span class="line">	gcc -c test.c -o test.o</span><br></pre></td></tr></table></figure>

<ul>
<li>可以在文件中定义”变量名 &#x3D; 变量值”的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。</li>
</ul>
<h1 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h1><h2 id="定义与作用"><a href="#定义与作用" class="headerlink" title="定义与作用"></a>定义与作用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -l a.out <span class="comment">#查看文件的格式和组成</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h prog.o //查看一个.o文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">file [file] <span class="comment">#命令通过ELF文件头检查文件类型。</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nm</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strip</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Executable and Linkable Format，作为二进制接口（Application Binary Interface，ABI）而开发和发布的。其中<code>.o</code> 可重定位文件、<code>.so</code>共享库(shared library)、<code>.out</code>可执行文件都是使用该格式描述的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) .text section  可执行代码；(只读、可fork后复用)</span><br><span class="line"><span class="number">2</span>) .data section  被初始化的数据；</span><br><span class="line"><span class="number">3</span>) .bss section   未被初始化的数据；(仅描述大小，不占空间)</span><br><span class="line"><span class="number">4</span>) .rec           重定位条目；</span><br><span class="line"><span class="number">5</span>) .symtab 或者 .dynsym section  符号信息；</span><br><span class="line"><span class="number">6</span>) .strtab 或者 .dynstr section  字符串信息；</span><br><span class="line"><span class="number">7</span>) 其他的section，比方满足调试的目的、满足动态链接与加载的目的等。</span><br></pre></td></tr></table></figure>

<h4 id="Text-amp-Data-amp-Bss"><a href="#Text-amp-Data-amp-Bss" class="headerlink" title="Text &amp; Data &amp; Bss"></a>Text &amp; Data &amp; Bss</h4><ul>
<li>.text： 也称为代码段(Code)，同时包含一些常量(如一些字符串常量等）。该段内存为静态分配，只读(某些架构可能允许修改)，是相同进程共享的。</li>
<li>.data： 全局数据区，也有的地方叫GVAR(global value)，用来存放程序中已经初始化的非零全局变量。静态分配。编译时为数据分配空间。<ul>
<li>data又可分为读写（RW）区域和只读（RO）区域。<br>-&gt; 常数区 （RO段）保存不可更改所以也被称为<code>.rodata</code><br>-&gt; 静态区（ RW段）则是普通非常量全局变量，静态变量就在其中</li>
</ul>
</li>
<li>.bss： 存放程序中未初始化的和初始化零值的全局变量。静态分配，在程序开始时分配空间且通常会被清零。只占运行时的内存空间而不占文件空间，但记录了大小。</li>
</ul>
<p>text和data段都在可执行文件中，由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。 </p>
<h4 id="堆栈（Heap-amp-Stack）"><a href="#堆栈（Heap-amp-Stack）" class="headerlink" title="堆栈（Heap&amp; Stack）"></a>堆栈（Heap&amp; Stack）</h4><p>堆和栈都是动态分配内存，两者空间大小都是可变的。</p>
<ul>
<li>Stack： 栈，存放Automatic Variables，按内存地址由高到低方向生长，其最大大小由编译时确定，速度快，通常是局部变量，函数参数等的存储区，最大空间不大。</li>
<li>Heap： 堆，自由申请的空间，按内存地址由低到高方向生长，其大小由系统内存&#x2F;虚拟内存上限决定，速度较慢，但自由性大，可用空间大。<br>每个线程都会有自己的栈，但是堆空间是共用的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 21:21:48" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-14 16:24:54" itemprop="dateModified" datetime="2022-09-14T16:24:54+08:00">2022-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul>
<li>for与while语句，都是先判断条件是否成立，然后再执行循环体</li>
<li>Range-based循环与auto：使用时注意是拷贝还是引用</li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><ul>
<li>iostream库包含两个基础类型istream（cin）、ostream（cout、cerr、clog）</li>
<li>流操纵符 endl ：缓冲刷新操作，结束当前行。注意程序崩溃时，输出可能还在缓冲区中。</li>
<li><code>while(std::cin &gt;&gt;value)</code> 检测cin对象，即检测流的状态。</li>
</ul>
<h1 id="惯用法"><a href="#惯用法" class="headerlink" title="惯用法"></a>惯用法</h1><ul>
<li><p>RAII惯用法 ：使用栈对象生命周期管理堆对象生命。</p>
</li>
<li><p>pimpl惯用法 ：在接口中不暴露内部实现，降低耦合，分离接口与实现。头文件中仅使用指针或智能指针。</p>
</li>
<li><p>统一初始化：统一的大括号初始化</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 17注解标签（attributes）</span></span><br><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;use fun1 instead&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">[[fallthrought]]        <span class="comment">//switch中故意fall</span></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>; <span class="comment">//必须关注返回值</span></span><br><span class="line">[[maybe_unused]] <span class="comment">//对未使用的函数和参数标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 11的enumerator</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span>&#123; <span class="comment">//给枚举值加命名空间</span></span><br><span class="line">    black,</span><br><span class="line">    white</span><br><span class="line">&#125;</span><br><span class="line">Color::black;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final、override关键字和=default、=delete语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span>&#123; <span class="comment">//不可继承</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 表明复写虚函数</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>; <span class="comment">// 使用默认实现</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) = <span class="keyword">delete</span>; <span class="comment">// 禁止拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++ 17结构化绑定 </span></span><br><span class="line"><span class="keyword">auto</span> [be, en] = <span class="built_in">equal_range</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">5</span>);<span class="comment">//左开右闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原位构造</span></span><br><span class="line">st.<span class="built_in">emplace</span>();</span><br><span class="line">vec.<span class="built_in">emplace_back</span>();</span><br><span class="line">mp.<span class="built_in">try_emplace</span>(); <span class="comment">//当key存在时，则放弃</span></span><br></pre></td></tr></table></figure>

<h1 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h1><p>使用va_list，va_start，va_arg，va_end。<br>也可以用宏定义##__VA_ARGS__，可以针对空参数消除逗号 </p>
<h1 id="mian函数前后运行代码"><a href="#mian函数前后运行代码" class="headerlink" title="mian函数前后运行代码"></a>mian函数前后运行代码</h1><p>定义在main( )函数之前的全局对象、静态对象的构造函数在main( )函数之前执行。<code>atexit()</code>在main之后运行。</p>
<h1 id="限定栈、堆创建"><a href="#限定栈、堆创建" class="headerlink" title="限定栈、堆创建"></a>限定栈、堆创建</h1><ul>
<li><p>静态建立一个类对象，由编译器分配内存、管理对象的整个生命周期。设置类的析构函数为私有的或保护的，编译器无法调用析构函数来释放内存。类中必须提供一个destory函数，来进行内存空间的释放，可以在内部直接调用类的构造函数。 </p>
</li>
<li><p>动态建立类对象，是使用new运算符将对象建立在堆空间中。将operator new()设为私有则不能再堆上建立对象。</p>
</li>
</ul>
<h1 id="内存拷贝函数"><a href="#内存拷贝函数" class="headerlink" title="内存拷贝函数"></a>内存拷贝函数</h1><p>手写strcpy、memcpy、strncpy、memset、memmove<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42914703/article/details/103323159">LINK</a></p>
<ul>
<li><p>判断地址是否为空 </p>
</li>
<li><p>目的地址和源地址重合的问题，拷贝前要判断目标首地址是否在原拷贝区间内。如果正向拷贝会立刻覆盖原内容，那就反向拷贝。</p>
</li>
<li><p>拷贝到’\0’时就会终止，要保证最终dest末尾是’\0’、因此要先保存dest的地址，便于最终返回。</p>
</li>
<li><p>即是未遇到原串的’\0’，如果已经复制了n个字符（n为提供的参数长度），复制同样会终止。</p>
</li>
<li><p>实现这个函数时一般要把原来的指针类型转换成char*</p>
</li>
</ul>
<h1 id="全局对象初始化顺序"><a href="#全局对象初始化顺序" class="headerlink" title="全局对象初始化顺序"></a>全局对象初始化顺序</h1><h1 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h1><ul>
<li>如何得到一个结构体内成员的偏移量？</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(s,m) ((::size_t)&amp;reinterpret_cast<span class="string">&lt;char const volatile&amp;&gt;</span>((((s*)0)-&gt;m)))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>手写如何通过一个结构体的成员变量得到一个结构体的地址？<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h16rjezwc1j20kc01nmxf.jpg" alt="img"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 21:21:48" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-01 12:52:48" itemprop="dateModified" datetime="2022-09-01T12:52:48+08:00">2022-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h2><p>阅读方法：从变量符号开始，按照优先级开始读。从里到外，从右到左结合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;		<span class="comment">//常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a; 		<span class="comment">//常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *a;		<span class="comment">//指针常量，不可通过指针所指向的内容</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> a;	<span class="comment">//常量指针，不可改变指针指向</span></span><br><span class="line"><span class="type">int</span> *p[<span class="number">10</span>];			<span class="comment">//数组中的元素为指针</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>];		<span class="comment">//指针指向数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">p</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">//函数，返回int指针</span></span><br><span class="line"><span class="built_in">int</span> (*p)(<span class="type">int</span>);	<span class="comment">//指针函数</span></span><br><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span> (parameter_list)) [dimension] <span class="comment">//返回数组指针的函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>char * const *(*next)()</code>  是什么类型？<br>以符号开始，从内向外，从右向左解析：是一个指针、指向一个函数，函数签名为<code>char * const * fun()</code>，返回类型是指针，指针类型为常量，指向一个字符指针。</li>
<li><code>int(*f(int,void(*)()))(int,int)</code>是什么类型？<br>一个函数，参数为int和指向返回值为void的无参数的函数指针，返回指针。指向参数为int和int，返回值为int的函数</li>
<li>数组名不是指针，但是当传参时会转换成首元素指针，支持自增操作，不支持<code>sizeof</code>运算。</li>
<li>野指针指未初始化的指针，悬空指针指所指对象已不存在的指针。</li>
</ul>
<h2 id="RAII与智能指针"><a href="#RAII与智能指针" class="headerlink" title="RAII与智能指针"></a>RAII与智能指针</h2><p>RAII即资源获取就是初始化，利用栈对象的生命周期来控制资源释放问题。<br><code>#include &lt;memory&gt;</code></p>
<ul>
<li><code>shared_ptr</code> 允许多个指针指向同一个对象，引用计数<ul>
<li><code>weak_ptr</code> 弱引用，不增加引用计数，指向<code>shared_ptr</code>管理的对象</li>
</ul>
</li>
<li><code>unique_ptr</code> 独占对象</li>
</ul>
<h2 id="pimpl"><a href="#pimpl" class="headerlink" title="pimpl"></a>pimpl</h2><p>类的组合方法：在类中不直接放子类成员，通过子类指针与构造函数初始化指针来获得与使用子类。<br><strong>降低耦合、编译依赖。</strong>原类的头文件一般不会被改变，因为类中只有一个指针抽象。此时对子类修改时，不需要重新编译原类。</p>
<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><p>引用不是对象，不能定义引用的引用（否则就是引用的别名了）。定义引用时必须初始化为有效值，并保持其引用的对象在引用的生命期内一直有效，sizeof&#96;所得的大小是引用对象的大小。<br>指针是对象，保存着另一个对象的地址，在所指向的对象无效时可以将指针置为nullptr，使用时要注意指针的有效性。而引用暗含了其引用对象的有效，当引用对象可能会无效，请使用指针并在无效时设为nullptr。</p>
<ul>
<li><code>operator[]</code>应该总是返回引用。std库在使用[]时默认所取元素有效。</li>
<li>不以多态的方式处理数组，因为指针移动时按照指针的静态类型大小移动。删除数组也是会通过指针类型来计算大小。</li>
<li>数组指针移动：<code> *(arr + 1) or *(&amp;arr + 1)</code>数组首元素指针加一移动一个元素长度，数组引用移动一个数组长度。</li>
<li>左值引用为常规引用，使用对象的空间，一般表示对象的身份。右值引用，一般是临时量，会窃取值空间。</li>
<li>引用折叠<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>请使用C++的转型操作符，因为旧的C转型语法结构导致意图不精确。</p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><ul>
<li>主要用于非多态类型的转换，如转换数值数据类型（如 float -&gt; int）</li>
<li>也可用于子类转化为父类。在父类转化为子类时不安全，因为不执行运行时类型检查。</li>
<li>不能转换掉expression的const、volatile和__unaligned属性。</li>
</ul>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><ul>
<li>用于多态类型的转换，所以只适用于指针或引用，会执行行运行时类型检查。</li>
<li>在对应的虚表中的RTTI去查找对应的类型来判断可不可以进行相应的转换。</li>
</ul>
<h5 id="bad-cast"><a href="#bad-cast" class="headerlink" title="bad_cast"></a>bad_cast</h5><ul>
<li>强制转换为指针类型失败，返回 nullptr，不引发异常</li>
<li>强制转换为引用类型失败，引发 bad_cast 异常。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Circle&amp; ref_circle = <span class="built_in">dynamic_cast</span>&lt;Circle&amp;&gt;(ref_shape);   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">catch</span> (bad_cast b) &#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Caught: &quot;</span> &lt;&lt; b.<span class="built_in">what</span>();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><ul>
<li>位的重新解释，允许任何类型之间的转换，危险</li>
<li>但无法删除 const、volatile 或 __unaligned（可按照非对齐访问） 特性。 </li>
<li>一个实际用途是在哈希函数中，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><p>类型安全语言是一种只能对数据执行的操作是数据类型所允许的操作。类型安全的代码不会试图访问自己没被授权的内存区域。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 21:21:48" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-07 15:41:15" itemprop="dateModified" datetime="2022-07-07T15:41:15+08:00">2022-07-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="using-声明"><a href="#using-声明" class="headerlink" title="using 声明"></a>using 声明</h2><p>头文件不应包含using声明，这会有入侵性，在不经意间引入名字，隐含着名字冲突。</p>
<p>用于只引入对应命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name::name;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的-using-声明"><a href="#构造函数的-using-声明" class="headerlink" title="构造函数的 using 声明"></a>构造函数的 using 声明</h3><p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(parms) : <span class="built_in">Base</span>(args) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="using-指示"><a href="#using-指示" class="headerlink" title="using 指示"></a>using 指示</h4><p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> namespace_name name;</span><br></pre></td></tr></table></figure>

<h4 id="尽量少使用-using-指示-污染命名空间"><a href="#尽量少使用-using-指示-污染命名空间" class="headerlink" title="尽量少使用 using 指示 污染命名空间"></a>尽量少使用 <code>using 指示</code> 污染命名空间</h4><blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<p>using 使用</p>
<p>尽量少使用 <code>using 指示</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<p>应该多使用 <code>using 声明</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">std::cin &gt;&gt; x ;</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="范围解析运算符"><a href="#范围解析运算符" class="headerlink" title=":: 范围解析运算符"></a>:: 范围解析运算符</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">11</span>;         <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;   <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">31</span>;     <span class="comment">// 初始化局部的 count 为 31</span></span><br><span class="line">    count = <span class="number">32</span>;         <span class="comment">// 设置局部的 count 的值为 32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ::count = <span class="number">12</span>;       <span class="comment">// 测试 1：设置全局的 count 的值为 12</span></span><br><span class="line"></span><br><span class="line">    A::count = <span class="number">22</span>;      <span class="comment">// 测试 2：设置类 A 的 count 为 22</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fun</span>();                <span class="comment">// 测试 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class与function的名称空间"><a href="#class与function的名称空间" class="headerlink" title="class与function的名称空间"></a>class与function的名称空间</h2><h3 id="在C语言中"><a href="#在C语言中" class="headerlink" title="在C语言中"></a>在C语言中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span> </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure>

<p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() &#123;&#125;</code>。</p>
<h3 id="在C-语言中"><a href="#在C-语言中" class="headerlink" title="在C++语言中"></a>在C++语言中</h3><p>由于<code>C++</code>编译器定位符号的规则（搜索规则）改变，导致不同于C语言。<br>一、如果在类标识符空间定义了 <code>struct Student &#123;...&#125;;</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，&quot;struct&quot; 关键字可省略</span></span><br></pre></td></tr></table></figure>

<p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123; </span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 &quot;Student&quot; 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 &quot;S&quot; 已经被定义为一个 &quot;struct Student&quot; 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Student</span>(); </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Student</span> me;      <span class="comment">// 或者 &quot;S me&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 21:21:48" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-14 18:51:13" itemprop="dateModified" datetime="2022-09-14T18:51:13+08:00">2022-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h1><p>存储金字塔：寄存器，三级缓存，内存，硬盘。它们之间的容量与访问速度是指数级差别。</p>
<p>伪共享：cache line的大小是固定的，其中一二级缓存不共享，当数据密集排布时，我们读写其中cache line其中的一个值，会导致其他核中的当前cache line 全部失效。所以不同核之间不共享的数据不要安排在同一个cache line大小之中。</p>
<h1 id="物理内存到虚拟内存"><a href="#物理内存到虚拟内存" class="headerlink" title="物理内存到虚拟内存"></a>物理内存到虚拟内存</h1><p>首先内核通过向BIOS发出中断，获取内存布局。由于可能<code>NUMA</code>架构存在，所以Linux首先将内存分为多个<strong>结点</strong>来代表不同距离间的内存。然后在每个结点内部又将内存分为不同的<strong>管理区间</strong><code>（DMA、NORMAL、HIGHMEM）</code>。其中<code>DMA</code>的内存是为了地址位短的设备保留的，<code>NORMAL</code>是内核线性映射的内存，<code>HIGHMEM</code>内存则是走页表动态映射使用的，这样一来可方便访问用户态内存，二来可以在内核内存碎片化时也能分配连续的虚拟内存。其中每个区间内的内存又会被划分成page管理。</p>
<p>内核在将内存分为不同的管理区间之后，首先可以使用<strong>伙伴系统</strong>分配2的幂次方倍个页面内存（减少外部碎片），也可以再通过基于伙伴系统的<code>slub</code>构建了<strong>小对象池</strong>来减少内部内存碎片。</p>
<p>虚拟内存使用逻辑地址而不是物理地址。Linux采用三层页表管理结构来管理虚拟内存，同时通过查询页表来完成虚拟地址到物理地址的转换。在硬件上，通常会有<code>TLB</code>来加速页表的查询过程。在经典的32位<code>x86</code>系统上，特别的将第二层中间目录表的大小改为一，则实际为两层页表。程序的逻辑地址也因此被分为四部分，前三部分对应着三层页表管理结构的偏移量，最后一部分对应着页内偏移量。在进程控制块中保存着第一层页表的物理地址，在切换进程时会将其加载至<code>cr3</code>寄存器，便会切换其内存映射。</p>
<h1 id="程序内存"><a href="#程序内存" class="headerlink" title="程序内存"></a>程序内存</h1><p>32位程序逻辑地址共有<code>4G</code>内存，其中0-3G是用户态内存，3-4G是内核内存。为何不在逻辑上将内核内存对程序屏蔽？为了速度，如<code>TLB</code>加速。虚拟内存的<code>page</code>是都是<code>4K</code>对齐的，所以通过三层页表查询到的页面地址的后几位一定为零，这快区域用于记录控制信息，比如是否换出，可读、可写、可执行等。</p>
<p>程序数据存储区域有：堆、栈、全局。其中堆内存基于<code>brk</code>与<code>mmap</code>系统调用提供<code>malloc</code>与<code>free</code>接口，而栈内存是函数内部通过定义局部对象的方式直接使用。栈内存比堆内存分配更快，因为栈内存分配只涉及栈指针移动，而堆内存分配需要复杂的分配算法。但栈内存上线比堆内存小，虽然栈可通过系统参数改变其大小限制。全局内存，是定义在<code>main函数</code>之外的对象所占的空间，<code>C++</code>运行库会在<code>main函数</code>之前将全局对象初始化，如果该对象未定义则会被分配到<code>bss</code>区，被自动置零。注意在混合使用<code>C</code>与<code>C++</code>语言时，请使用<code>C++</code>的main入口函数实现，因为C的运行库并不会将<code>C++</code>的对象初始化。</p>
<ul>
<li><p>堆内存与栈内存区别<br>栈内存是函数局部变量使用，自动分配，而堆内存需要语句显式分配。<br>栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br>栈由系统分配，速度快，不会有碎片。堆由程序员分配，速度慢，且会有碎片。</p>
</li>
<li><p>声明与定义区别<br>声明阐述了数据的操作方法。定义则分配了数据存储的内存。相同变量可以再多处声明（外部变量extern），但只能在一处定义。</p>
</li>
<li><p><strong><code>memmove </code>函数与 <code>memcpy </code>函数的实现区别</strong><br><code>memcpy</code>只是简单的将两块内存区域当作没有关系的相互独立内存区域进行内存的拷贝<br><code>memmove</code>则考虑了当两块内存区域有重叠时所采用不同方向的拷贝模式进行处理</p>
</li>
</ul>
<h1 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h1><p>比较重要的<code>malloc</code>的实现有：</p>
<ol>
<li><code>ptmalloc2</code>：glibc内置</li>
<li><code>tcmalloc</code>：<code>google</code>为多线程优化</li>
</ol>
<h2 id="new、delete"><a href="#new、delete" class="headerlink" title="new、delete"></a>new、delete</h2><p><code>C++</code>中的new与delete，负责了内存分配与对象的构造的两段工作。在删除数组对象时，请使用<code>delete[]</code>，在数组的前方有表明数组大小的信息帮助析构与释放内存。</p>
<ul>
<li><p>如果new申请内存失败了，如何解决？如果让你实现一个new，你会怎么实现？<br>如果申请失败可以通过set_new_handler来进行处理。 实现：需要注意申请失败，如果相应的处理函数则调用，否则抛出bad_alloc异常 </p>
</li>
<li><p><strong>对一个数组而言，delete a和delete[] a有什么区别？为什么？</strong><br>对于基础数据类型没有什么区别，对于对象delete值调用一次析构函数，delete[]才会析构所有的东西。</p>
</li>
</ul>
<h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p>用于在已分配内存的地址上构造对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="built_in">new</span> (place_address) <span class="built_in">type</span> (initializers)</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size]</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size] &#123; braced initializer list &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>place_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h2 id="成员函数delete-this-合法吗？"><a href="#成员函数delete-this-合法吗？" class="headerlink" title="成员函数delete this 合法吗？"></a>成员函数delete this 合法吗？</h2><ol>
<li>成员函数在全局函数中，与对象无关。</li>
<li>但必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、 placement new、栈上、全局、或者其他对象成员分配的），且不在使用该对象。</li>
</ol>
<h1 id="STL内存"><a href="#STL内存" class="headerlink" title="STL内存"></a><code>STL</code>内存</h1><ul>
<li>内存分配器</li>
</ul>
<p>大于128字节的直接使用<code>malloc</code>申请该大小内存，其他使用8字节倍数大小内存申请，为了地址对齐。</p>
<ul>
<li>array</li>
</ul>
<p>固定长度的数组，长度也是类型的一部分，在作为参数传递时仍保留了长度信息，可以完全代替C语⾔的传统数组。</p>
<ul>
<li>vector</li>
</ul>
<p>实现：三个指针分别指向数组首元素，有效元素后一个，无效元素后一个。</p>
<p>内存：二倍扩容，达到最终容量n的情况下，分配的成本为<code>O(n)</code>。</p>
<p>取首元素指针：<code>&amp;v[0]</code></p>
<ul>
<li><code>deque、stack、queue</code></li>
</ul>
<p>双端队列，一个中央控制器 + 多个连续数组，支持首尾快速增删，支持随机访问。</p>
<p><code>stack\queue</code>一般底层使用<code>deque</code>作为容器。也可使用vector。</p>
<ul>
<li>priority_queue</li>
</ul>
<p>使用vector作为容器，在上面做最大堆的算法。</p>
<ul>
<li><code>map、set、multimap、multiset</code></li>
</ul>
<p>红黑树，插入、删除、查找的时间复杂度都是 <code>O(log2n)</code>，内部有序。</p>
<ul>
<li><code>unordered_map、unordered_set、unordered_multiset、unordered_multimap</code></li>
</ul>
<p>插入、删除、查找 O(1) 、最差 O(n)，内部无序</p>
<h2 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h2><p>迭代器失效警告：clang编译器加上 <code>fsanitize=undefined</code></p>
<h3 id="数组式容器"><a href="#数组式容器" class="headerlink" title="数组式容器"></a>数组式容器</h3><p>插入与删除之后所有迭代器失效。插入元素导致重新分配内存，则迭代器全部失效。</p>
<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>删除只会导致当前迭代器失效，插入不会导致任何迭代器失效。</p>
<h3 id="Deque式容器"><a href="#Deque式容器" class="headerlink" title="Deque式容器"></a>Deque式容器</h3><p>插入头尾：迭代器全部失效但是引用不失效。（中控器重新分配内存，缓存区未重新分配）删除头尾：被删除的元素迭代器和引用失效。插入和删除中间：迭代器和引用全部失效。（缓存区中元素移动，导致边界移动 ）</p>
<p>其中插入头尾操作引用不失效的原因是，deque由一个map和连续数组组成，其中map是指向数组的指针即二级指针，当插入头尾时，如果内存不够，会①复制原map的信息②申请新的连续空间作为map③存入旧的map信息，然后再插入新的数据。而deque的迭代器中存放着cur(当前数组的位置）first和end（当前map节点的首位地址）和node（当前map的节点地址），所以由于map的从新分配，迭代器的node失效，但是原map指向的连续数组并没有从新分配。</p>
<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h1><p><code>C++</code>标准只规定了最小的size，所以不同的实现上可能不同。</p>
<ul>
<li><p>float是32位，double 是64位，int一般是32位</p>
</li>
<li><p><code>strlen</code>是字符串指针函数，<code>sizeof</code>是运算符，参数是任意数据或类型，数值来自编译器对内存的安排。</p>
</li>
<li><p>指针大小取决于虚拟地址位数。</p>
</li>
<li><p>引用大小取决于被引用的对象大小</p>
</li>
<li><p>数组在作为函数的参数时自动转为首元素指针，所以在函数内部<code>sizeof</code>为指针大小。整个数组所占空间大小。</p>
</li>
</ul>
<h1 id="对象内存"><a href="#对象内存" class="headerlink" title="对象内存"></a>对象内存</h1><p>为了保证所有的对象的地址唯一，空类、空结构体大小为1字节。否则，对象的大小只由非静态成员、虚函数指针、内存对齐影响。</p>
<h1 id="结构体内存"><a href="#结构体内存" class="headerlink" title="结构体内存"></a>结构体内存</h1><p>64位CPU表示可一次进行64位数据运算，因此数据总线一般也是64位。此时地址总线一般是64位（实际地址总线比这小，一是因为没人会有那么多的内存条，二是因为低位地址线总是为零）。字节对齐的原因是CPU访问内存时一般只能向内存按照$2^n$寻址（低位地址线被省略,，导致不能任意字节地址寻址），如果数据跨过这个整数倍就必须读取两次。</p>
<ol>
<li><code>struct </code>与<code>class </code>的区别在于默认的访问控制。</li>
<li>不能直接比较结构体，因为字节对齐多出来的内存是随机的，可能不相等，必须要一个个成员比较。 </li>
<li><code>static</code>元素不在<code>struct</code>实例的内部</li>
</ol>
<h1 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h1><p>原则：对齐指按其元素大小整数倍地址存放。结构体对齐需要让所有元素都能够对齐访问，即使结构体排成数组时或结构体内部有结构体也能对齐所有的元素。</p>
<ol>
<li><p>按照声明顺序存储，结构体起始地址按首元素大小整数倍开始存放。</p>
</li>
<li><p>其他内部元素按照首元素长度与本身长度整数倍公约数对齐。</p>
<ol>
<li>内部结构体按照首元素长度与其内部最宽成员长度公约数对齐。</li>
</ol>
</li>
<li><p>最后结构体的总大小需要按照内部最宽的基本类型补齐。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n取值一般为2^n。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(n / <span class="type">double</span>) MyType&#123; <span class="comment">//设置对齐成n字节或double对齐。</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">alignof</span>(MyType); <span class="comment">//查询对齐</span></span><br><span class="line"><span class="built_in">alignof</span>(<span class="type">max_align_t</span>); <span class="comment">//最大标量对齐</span></span><br><span class="line"><span class="comment">//在ptr指向的大小为space的内存中的size大小的数据调整为按bound进行对齐。</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">align</span><span class="params">(<span class="type">size_t</span> bound, <span class="type">size_t</span> size, <span class="type">void</span>*&amp; ptr, <span class="type">size_t</span>&amp; space)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//编译器#pragma pack(n)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push) <span class="comment">// 将当前pack设置压栈保存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)<span class="comment">// 必须在结构体定义之前使用</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S3</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  S1 s;</span><br><span class="line">  <span class="type">char</span> c2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop) <span class="comment">// 恢复先前的pack设置</span></span></span><br><span class="line"><span class="comment">//计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)</span></span><br><span class="line"><span class="comment">//等于6，能够被2整除，所以整个S1的大小为6。</span></span><br><span class="line"><span class="comment">//同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能</span></span><br><span class="line"><span class="comment">//被2整除，添加一个填充字节，所以sizeof(S3)等于10。</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://younif.github.io/2022/09/18/C++/%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Youni">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Youni Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/C++/%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 21:21:48" itemprop="dateCreated datePublished" datetime="2022-09-18T21:21:48+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-01 10:57:38" itemprop="dateModified" datetime="2022-09-01T10:57:38+08:00">2022-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><p>union用于在同一空间中的不同时期中存储不同的内容，以节省空间。表面上看起来内部有多个类型，但某一时刻只能存储其中的某一种。默认访问控制符为 public，可以含有构造函数、析构函数。</p>
<ul>
<li>匿名 union 在定义所在作用域可直接访问 union 成员，但不能包含 protected 成员或 private 成员</li>
<li>全局匿名 union 必须是静态（static）的</li>
</ul>
<h3 id="union判断大小端"><a href="#union判断大小端" class="headerlink" title="union判断大小端"></a>union判断大小端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">UnionTest</span> &#123;</span><br><span class="line">    <span class="built_in">UnionTest</span>() : <span class="built_in">i</span>(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; u.i &lt;&lt; std::endl;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    std::cout &lt;&lt; ::i &lt;&lt; std::endl;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>extern用于声明其他模块的全局变量或函数，但如果此时给与初始化值则会在本模块定义并分配内存。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">extern参考资料</a></p>
<h1 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h1><p>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的，可以避免<code> C++</code> 因符号修饰而导致代码不能和C语言库中的符号进行链接的问题。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>关键：全局可见性、静态存储区、脱离对象实例、初始化。</p>
<ol>
<li>修改全局变量、函数，表明仅在本文件使用。共享要在声明与定义同时添加extern。</li>
<li>修饰局部变量，延长变量生存期，使得函数具有状态。</li>
<li>修饰成员变量，使其成为类的共有变量，只能在类外被定义。</li>
<li>修饰成员函数，使其不隐含this指针，只能访问static成员变量。</li>
</ol>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>为了取代预编译的符号常量导致的debug困难。const作为编译期常量可以保存在符号表中，仅在文件内有效，共享需要在声明与定义添加extern关键字。</p>
<ol>
<li><p>修饰变量，不可改变；</p>
</li>
<li><p>修饰指针，分为指向常量的指针，常量的指针</p>
</li>
<li><p>修饰引用，指向常量的引用（reference to const）。常用于函数形参，避免拷贝且限制对值修改；</p>
</li>
<li><p>修饰成员函数，限制该函数修改成员变量。</p>
</li>
</ol>
<ul>
<li><p>常引用，用于引用一个对象，且限制使用该引用修改对象，常用于形参传递。</p>
<ul>
<li><strong>下面这两个函数在执行过程中有什么区别</strong>？<br><code>int f(string&amp;a); f(“abc”);//报错</code><br><code>int f(const string&amp;a); f(“abc”);//正常</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">指针</span><br><span class="line">*  <span class="type">const</span>只修饰其后的【变量】，<span class="type">const</span>放在类型前还是类型后并没有区别 </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p<span class="comment">//指向的值不可变</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *p<span class="comment">//指向的值不可变</span></span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p<span class="comment">//地址不可变, 那个地址指向的值可以变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p<span class="comment">//地址和值都不可变</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> *<span class="type">const</span> p<span class="comment">//地址和值都不可变</span></span><br><span class="line">常引用</span><br><span class="line">- <span class="type">const</span> <span class="type">int</span> &amp; a = b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="keyword">class</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">a</span>(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">a</span>(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="type">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="type">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="type">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function2</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function3</span><span class="params">(<span class="type">char</span>* <span class="type">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function4</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="type">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<h1 id="static-const"><a href="#static-const" class="headerlink" title="static const"></a>static const</h1><ul>
<li>const、static、const static 声明、定义、初始化</li>
</ul>
<p>规则：const，必须在内部声明、定义、初始化。<br>static，必须在内部声明、在外部定义、在外部初始化。<br>const static，必须在内部声明、在外部定义、必须初始化，但位置随便。</p>
<p>解释：static变量只与类有关，在类内部只能声明，在内部无法初始化也无法被定义！必须在类的外部进行定义、初始化。未在外部定义的static成员表现出来链接错误。const static作为static成员，也必须在外部定义，否则连接错误。const成员一般在初始化表中初始化，（或者仅作为编译期常量）。</p>
<p>类的初始化列表是用于实例化对象，不能用于static成员。</p>
<p><a href="#">static函数能定义为虚函数吗？能定义为const函数吗？</a><br>因为static函数不属于对象，只能操作static成员变量，所以不能为虚函数。 因为const修饰的是this指针，static函数没有this指针，所以也不能为const函数。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>多线程共享变量，可能会导致CPU间cache数据不一致。volatile强制其不能在每CPU cache中保存、读取来避免该问题。（告诉编译器该变量可能会在当前控制流之外发生变化。）</p>
<h2 id="const-volatile"><a href="#const-volatile" class="headerlink" title="const volatile"></a>const volatile</h2><p>只读易变元素，volatile表示该值可能会被其他CPU所改变，但本段代码不应该修改它。</p>
<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>中断服务子程序修该一个指向一个buffer的指针时。如下面的函数有什么错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> ptr)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ptr*ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的目的是用来返指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> ptr)</span>&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">a = ptr;</span><br><span class="line">b = ptr;</span><br><span class="line"><span class="keyword">return</span> ab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ptr的值可能被意想不到地该变，因此a和b可能是不同的。正确做法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">square</span><span class="params">(<span class="keyword">volatile</span> <span class="type">int</span> ptr)</span>&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">a = ptr;</span><br><span class="line"><span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>decltype 关键字用于获取实体的声明类型或表达式的类型及值分类。语法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span> ( expression )</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Youni</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Youni</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
